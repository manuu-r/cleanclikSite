<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sparcd Technical Documentation</title>
  <style>
    :root {
      --bg: #f7fafc;
      --card: #ffffff;
      --ink: #1f2937;
      --muted: #4b5563;
      --line: #d9e2ef;
      --accent: #0f766e;
      --code-bg: #f1f5f9;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    main {
      max-width: 980px;
      margin: 34px auto;
      padding: 0 18px;
    }
    article {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 28px;
    }
    h1, h2 { margin: 0 0 12px; }
    h1 { font-size: 1.9rem; }
    h2 {
      margin-top: 26px;
      font-size: 1.15rem;
      color: var(--accent);
    }
    p { margin: 10px 0; color: var(--ink); }
    ul { margin: 8px 0; padding-left: 20px; }
    li { margin: 6px 0; }
    code {
      background: var(--code-bg);
      padding: 2px 6px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 0.92em;
    }
    .meta { color: var(--muted); font-size: 0.95rem; }
    .spec {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 12px 14px;
      margin: 10px 0;
      background: #fbfdff;
    }
    .mermaid {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fcfeff;
      margin: 12px 0 16px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({ startOnLoad: true, theme: "default", securityLevel: "loose" });
  </script>
</head>
<body>
  <main>
    <article>
      <h1>Sparcd Technical Documentation</h1>
      <p class="meta">Tech stack, architecture, core flows, and RevenueCat implementation</p>

      <h2>1) Tech Stack</h2>
      <ul>
        <li><strong>Mobile</strong>: Flutter, Dart, Riverpod, GoRouter, Dio, Firebase Messaging, local notifications.</li>
        <li><strong>Backend</strong>: FastAPI (async), Pydantic, JWT auth, OAuth providers (Google/Apple).</li>
        <li><strong>Data</strong>: MongoDB + Beanie ODM, Redis.</li>
        <li><strong>AI</strong>: Gemini models with Google Search grounding and tier-based model routing.</li>
        <li><strong>Billing</strong>: RevenueCat SDK on client + backend webhook/refresh sync.</li>
        <li><strong>Infra</strong>: Docker, Docker Compose, GitHub Actions deployment workflows.</li>
      </ul>

      <h2>2) Runtime Architecture</h2>
      <p>
        Sparcd runs as a client-server system where the Flutter app handles interaction and rendering,
        while the FastAPI backend orchestrates AI planning, state transitions, notifications, and monetization gates.
      </p>
      <div class="mermaid">
graph TD
  A[Flutter App] -->|REST /v1| B[FastAPI API Layer]
  B --> C[Goal + Task Engines]
  C --> D[Gemini + Grounding]
  B --> E[(MongoDB/Beanie)]
  B --> F[(Redis)]
  B --> G[Notification Scheduler]
  G --> H[Firebase Cloud Messaging]
  H --> A
  B --> I[RevenueCat Service]
      </div>

      <h2>3) API Surface</h2>
      <p>
        The backend is versioned under <code>/v1</code> and grouped by route modules:
      </p>
      <div class="spec">
        <ul>
          <li><code>/auth</code> for signup/login/refresh/social auth</li>
          <li><code>/profile</code> for persona and profile controls</li>
          <li><code>/goals</code> for goal CRUD and analysis triggers</li>
          <li><code>/tasks</code> for daily task retrieval, generation/reveal, completion, skip/pause/snooze</li>
          <li><code>/milestones</code> and <code>/progress</code> for journey tracking</li>
          <li><code>/ai</code> for analysis and diagnostics</li>
          <li><code>/billing</code> for RevenueCat webhook and subscription refresh</li>
          <li><code>/insights</code> for insight endpoints</li>
        </ul>
      </div>

      <h2>4) Goal-to-Execution Flow</h2>
      <p>
        Sparcdâ€™s core behavior loop is intentionally structured: analyze goal, generate journey, reveal
        daily tasks, update streak/milestones, then adapt if the user stalls.
      </p>
      <div class="mermaid">
sequenceDiagram
  participant U as User
  participant APP as Flutter App
  participant API as FastAPI
  participant GA as Goal Analyzer
  participant JG as Journey Generator
  participant TD as Task Designer
  participant MT as Milestone Tracker
  participant AA as Adaptive Adjuster

  U->>APP: Create goal
  APP->>API: POST /v1/goals
  APP->>API: POST /v1/goals/{goal_id}/analyze
  API->>GA: Grounded goal analysis
  API->>JG: Generate full journey (skeleton -> detail)
  APP->>API: POST /v1/tasks/generate-today
  API->>TD: Reveal today's batch
  U->>APP: Complete/skip task
  APP->>API: Task status update
  API->>MT: Recompute milestone progress
  API->>AA: If stall patterns detected, regenerate remaining tasks
      </div>

      <h2>5) AI and Personalization Specs</h2>
      <ul>
        <li><strong>Tier-based model routing</strong>: free/pro users can be routed to different Gemini models.</li>
        <li><strong>Grounded generation</strong>: analysis and planning flows can include web grounding and citations metadata.</li>
        <li><strong>Two-phase journey generation</strong>: a skeleton pass for structure, then detail enrichment for behavioral fields.</li>
        <li><strong>Persona-aware prompting</strong>: planner and messaging layers adjust framing by persona profile.</li>
        <li><strong>Adaptive re-planning</strong>: skip/stall signals trigger lower-friction task regeneration for remaining journey days.</li>
      </ul>

      <h2>6) Data Model Specs</h2>
      <div class="spec">
        <p><strong>UserProfile highlights</strong></p>
        <ul>
          <li>Persona, psychological profile dimensions, and behavior signals.</li>
          <li>Notification behavior fields: response rate, streak sensitivity, last daily notification timestamp.</li>
          <li>Subscription fields: tier, entitlements, last subscription sync timestamp.</li>
          <li>Auth profile: email/password, social providers, verification and reset fields.</li>
        </ul>
      </div>
      <div class="spec">
        <p><strong>Task highlights</strong></p>
        <ul>
          <li>Tiny-habit structure: anchor moment, tiny version, celebration prompt.</li>
          <li>Ability factors for friction scoring (time, effort, brain cycles, money, routine).</li>
          <li>Journey fields: <code>day_number</code>, <code>revealed</code>, <code>journey_day_revealed_at</code>, <code>milestone_id</code>.</li>
          <li>Execution fields: priority, due date, status, pause/snooze metadata.</li>
          <li>Action link fields for external opportunities: <code>action_link</code>, <code>action_label</code>.</li>
        </ul>
      </div>

      <h2>7) Notification Delivery Specs</h2>
      <ul>
        <li>Scheduler starts with app lifespan and runs periodic ticks.</li>
        <li>Processes users with valid FCM tokens and timezone-aware local windows.</li>
        <li>Selects eligible task pool (today + overdue), then applies timing logic.</li>
        <li>Supports tier-aware reminder timing (optimized notification mode for premium gate).</li>
        <li>Sends high-priority FCM payloads with deep links and task metadata.</li>
      </ul>
      <div class="mermaid">
flowchart LR
  A[Scheduler Tick] --> B[Load Users with FCM]
  B --> C[Resolve Local Time Window]
  C --> D[Select Pending/Overdue Task]
  D --> E[Compose Persona-Aware Reminder]
  E --> F[Send FCM]
  F --> G[Persist last_daily_notification_at]
      </div>

      <h2>8) RevenueCat Implementation</h2>
      <p>
        RevenueCat is implemented as both a client purchase layer and a backend entitlement authority.
        The backend supports webhook ingestion and manual refresh for deterministic subscription state.
      </p>
      <ul>
        <li><code>POST /v1/billing/revenuecat/webhook</code>: validates webhook auth, resolves user by <code>app_user_id</code>/<code>aliases</code>, and schedules async sync.</li>
        <li><code>POST /v1/billing/refresh</code>: authenticated user-triggered refresh of tier and active entitlements.</li>
      </ul>
      <div class="mermaid">
sequenceDiagram
  participant RC as RevenueCat
  participant API as Billing API
  participant SVC as RevenueCat Service
  participant DB as UserProfile

  RC->>API: POST /v1/billing/revenuecat/webhook
  API->>API: Verify webhook auth
  API->>SVC: find_user_by_app_user_ids(...)
  API->>SVC: sync_user_subscription(...)
  SVC->>RC: Fetch customer (V2 API)
  SVC->>DB: Update tier + entitlements + timestamp
      </div>

      <h2>9) Subscription Gates and Feature Access</h2>
      <p>
        Feature gates are tier-driven (<code>free</code>, <code>pro</code>) and used across guidance depth,
        notification optimization, memory access window, and advanced AI capabilities.
      </p>
      <ul>
        <li>Goal creation limits by tier.</li>
        <li>Premium-only flags for advanced guidance and optimized notifications.</li>
        <li>Entitlements persisted in user records after webhook/manual sync.</li>
      </ul>

      <h2>10) Reliability and Ops Notes</h2>
      <ul>
        <li>Async architecture for API and background scheduler workflows.</li>
        <li>Fallback behavior in AI flows to reduce hard failures when model calls fail or rate-limit.</li>
        <li>Containerized deployment for reproducibility across environments.</li>
        <li>Health endpoint available at <code>/health</code>.</li>
      </ul>
    </article>
  </main>
</body>
</html>
